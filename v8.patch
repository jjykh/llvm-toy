diff --git a/.gitattributes b/.gitattributes
index b3e9762a93..06558cde43 100644
--- a/.gitattributes
+++ b/.gitattributes
@@ -5,3 +5,6 @@
 *.png binary
 # Don't include minified JS in git grep/diff output
 test/mjsunit/asm/sqlite3/*.js -diff
+
+*.so binary
+
diff --git a/BUILD.gn b/BUILD.gn
index c486f1a1c8..b238fcd824 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -202,6 +202,20 @@ declare_args() {
   # Use token threaded dispatch for the regular expression interpreter.
   # Use switch-based dispatch if this is false
   v8_enable_regexp_interpreter_threaded_dispatch = true
+
+  #if UC_BUILD_TF_LLVM_BACKEND
+  v8_enable_llvm = false
+
+  #endif
+}
+
+#if UC_BUILD_TF_LLVM_BACKEND
+if (uc_build_tf_llvm_backend && current_toolchain == v8_snapshot_toolchain) {
+  v8_enable_llvm = true
+}
+if (v8_enable_llvm) {
+  v8_enable_disassembler = true
+  v8_enable_object_print = true
 }
 
 # Derived defaults.
@@ -325,6 +339,9 @@ config("external_config") {
     "include",
     "$target_gen_dir/include",
   ]
+  if (v8_enable_llvm) {
+    configs += [ ":llvm_configs" ]
+  }
 }
 
 # This config should only be applied to code that needs to be explicitly
@@ -748,6 +765,19 @@ config("always_optimize") {
   }
 }
 
+#if UC_BUILD_TF_LLVM_BACKEND
+if (v8_enable_llvm) {
+  config("llvm_configs") {
+    include_dirs = [ "src/llvm/include" ]
+    libs = [ "LLVM-8" ]
+    defines = [ "LLVMLOG_LEVEL=1" ]
+    ldflags = [ "-Wl,-rpath,../../v8/lib" ]
+
+    lib_dirs = [ "lib/" ]
+  }
+}
+
+#endif
 # Configs for code coverage with gcov. Separate configs for cflags and ldflags
 # to selectively influde cflags in non-test targets only.
 config("v8_gcov_coverage_cflags") {
@@ -1652,6 +1682,13 @@ v8_source_set("v8_init") {
   ]
 
   configs = [ ":internal_config" ]
+
+  #if UC_BUILD_TF_LLVM_BACKEND
+  if (v8_enable_llvm) {
+    configs += [ ":llvm_configs" ]
+  }
+
+  #endif
 }
 
 # This is split out to be a non-code containing target that the Chromium browser
@@ -1973,6 +2010,56 @@ v8_source_set("v8_compiler") {
   ]
 
   configs = [ ":internal_config" ]
+
+  #if UC_BUILD_TF_LLVM_BACKEND
+  if (v8_enable_llvm) {
+    llvm_sources = [
+      "src/llvm/abbreviated-types.h",
+      "src/llvm/abbreviations.h",
+      "src/llvm/basic-block-manager.cc",
+      "src/llvm/basic-block-manager.h",
+      "src/llvm/basic-block.cc",
+      "src/llvm/basic-block.h",
+      "src/llvm/common-values.cc",
+      "src/llvm/common-values.h",
+      "src/llvm/compile.cc",
+      "src/llvm/compile.h",
+      "src/llvm/compiler-state.cc",
+      "src/llvm/compiler-state.h",
+      "src/llvm/exception-table-arm.cc",
+      "src/llvm/exception-table-arm.h",
+      "src/llvm/initialize-llvm.cc",
+      "src/llvm/initialize-llvm.h",
+      "src/llvm/intrinsic-repository.cc",
+      "src/llvm/intrinsic-repository.h",
+      "src/llvm/liveness-analysis-visitor.cc",
+      "src/llvm/liveness-analysis-visitor.h",
+      "src/llvm/llvm-headers.h",
+      "src/llvm/llvm-tf-builder.cc",
+      "src/llvm/llvm-tf-builder.h",
+      "src/llvm/load-constant-recorder.cc",
+      "src/llvm/load-constant-recorder.h",
+      "src/llvm/llvm-log.cc",
+      "src/llvm/llvm-log.h",
+      "src/llvm/output.cc",
+      "src/llvm/output.h",
+      "src/llvm/stack-map-info.cc",
+      "src/llvm/stack-map-info.h",
+      "src/llvm/stack-maps.cc",
+      "src/llvm/stack-maps.h",
+      "src/llvm/tf/schedule-emitter.cc",
+      "src/llvm/tf/schedule-emitter.h",
+      "src/llvm/tf/tf-visitor.h",
+      "src/llvm/tf/v8-code-assemble.cc",
+      "src/llvm/tf/v8-code-assemble.h",
+      "src/llvm/tf/v8-pass-manager.cc",
+      "src/llvm/tf/v8-pass-manager.h",
+    ]
+    sources += llvm_sources
+    configs += [ ":llvm_configs" ]
+  }
+
+  #endif
 }
 
 group("v8_compiler_for_mksnapshot") {
@@ -3841,6 +3928,32 @@ if (current_toolchain == v8_generator_toolchain) {
 }
 
 if (v8_use_snapshot && current_toolchain == v8_snapshot_toolchain) {
+  v8_executable("mkwasmsnapshot") {
+    visibility = [ ":*" ]  # Only targets in this file can depend on this.
+
+    sources = [
+      "src/snapshot/mkwasmsnapshot.cc",
+    ]
+
+    configs = [ ":internal_config" ]
+
+    #if UC_BUILD_TF_LLVM_BACKEND
+    if (v8_enable_llvm) {
+      configs += [ ":llvm_configs" ]
+    }
+
+    #endif
+
+    deps = [
+      ":v8_base_without_compiler",
+      ":v8_compiler_for_mksnapshot",
+      ":v8_libbase",
+      ":v8_libplatform",
+      ":v8_snapshot",
+      "//build/win:default_exe_manifest",
+    ]
+  }
+
   v8_executable("mksnapshot") {
     visibility = [ ":*" ]  # Only targets in this file can depend on this.
 
@@ -3862,6 +3975,13 @@ if (v8_use_snapshot && current_toolchain == v8_snapshot_toolchain) {
 
     configs = [ ":internal_config" ]
 
+    #if UC_BUILD_TF_LLVM_BACKEND
+    if (v8_enable_llvm) {
+      configs += [ ":llvm_configs" ]
+    }
+
+    #endif
+
     deps = [
       ":v8_base_without_compiler",
       ":v8_compiler_for_mksnapshot",
@@ -4200,6 +4320,10 @@ v8_executable("d8") {
   if (v8_use_perfetto) {
     deps += [ "//third_party/perfetto/include/perfetto/tracing" ]
   }
+
+  if (uc_build_tf_llvm_backend) {
+    deps += [ ":mkwasmsnapshot($v8_snapshot_toolchain)" ]
+  }
 }
 
 v8_executable("v8_hello_world") {
diff --git a/gni/v8.gni b/gni/v8.gni
index 769a126a17..94d3d48471 100644
--- a/gni/v8.gni
+++ b/gni/v8.gni
@@ -128,7 +128,13 @@ if (is_debug && !v8_optimized_debug) {
   # TODO(crbug.com/621335) Rework this so that we don't have the confusion
   # between "optimize_speed" and "optimize_max".
   if (((is_posix && !is_android) || is_fuchsia) && !using_sanitizer) {
-    v8_add_configs += [ "//build/config/compiler:optimize_speed" ]
+#if UC_BUILD_TF_LLVM_BACKEND
+    if (uc_build_tf_llvm_backend) {
+      v8_add_configs += [ "//build/config/compiler:no_optimize" ]
+    } else {
+      v8_add_configs += [ "//build/config/compiler:optimize_speed" ]
+    }
+#endif
   } else {
     v8_add_configs += [ "//build/config/compiler:optimize_max" ]
   }
diff --git a/src/builtins/builtins-utils-gen.h b/src/builtins/builtins-utils-gen.h
index f9e2ba74fa..49234d4775 100644
--- a/src/builtins/builtins-utils-gen.h
+++ b/src/builtins/builtins-utils-gen.h
@@ -49,6 +49,31 @@ class CodeAssemblerState;
   }                                                                     \
   void Name##Assembler::Generate##Name##Impl()
 
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+#define TF_BUILTIN_LLVM(Name, AssemblerBase)                            \
+  class Name##Assembler : public AssemblerBase {                        \
+   public:                                                              \
+    using Descriptor = Builtin_##Name##_InterfaceDescriptor;            \
+                                                                        \
+    explicit Name##Assembler(compiler::CodeAssemblerState* state)       \
+        : AssemblerBase(state) {}                                       \
+    void Generate##Name##Impl();                                        \
+                                                                        \
+    Node* Parameter(Descriptor::ParameterIndices index) {               \
+      return CodeAssembler::Parameter(static_cast<int>(index));         \
+    }                                                                   \
+  };                                                                    \
+  void Builtins::Generate_##Name(compiler::CodeAssemblerState* state) { \
+    Name##Assembler assembler(state);                                   \
+    state->set_llvm_enabled(true);                                      \
+    state->SetInitialDebugInformation(#Name, __FILE__, __LINE__);       \
+    if (Builtins::KindOf(Builtins::k##Name) == Builtins::TFJ) {         \
+      assembler.PerformStackCheck(assembler.GetJSContextParameter());   \
+    }                                                                   \
+    assembler.Generate##Name##Impl();                                   \
+  }                                                                     \
+  void Name##Assembler::Generate##Name##Impl()
+#endif
 }  // namespace internal
 }  // namespace v8
 
diff --git a/src/codegen/arm/assembler-arm.cc b/src/codegen/arm/assembler-arm.cc
index 9c46063537..e02f05114f 100644
--- a/src/codegen/arm/assembler-arm.cc
+++ b/src/codegen/arm/assembler-arm.cc
@@ -493,6 +493,10 @@ const Instr kBlxRegMask =
     15 * B24 | 15 * B20 | 15 * B16 | 15 * B12 | 15 * B8 | 15 * B4;
 const Instr kBlxRegPattern = B24 | B21 | 15 * B16 | 15 * B12 | 15 * B8 | BLX;
 const Instr kBlxIp = al | kBlxRegPattern | ip.code();
+#if defined(UC_BUILD_TF_LLVM_BACKEND)
+const Instr kBlOffsetMask = B27 | B26 | B25 | B24;
+const Instr kBlOffsetPattern = B27 | B25 | B24;
+#endif
 const Instr kMovMvnMask = 0x6D * B21 | 0xF * B16;
 const Instr kMovMvnPattern = 0xD * B21;
 const Instr kMovMvnFlip = B22;
@@ -626,6 +630,9 @@ Instr Assembler::SetLdrRegisterImmediateOffset(Instr instr, int offset) {
   bool positive = offset >= 0;
   if (!positive) offset = -offset;
   DCHECK(is_uint12(offset));
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+  CHECK(is_uint12(offset));
+#endif
   // Set bit indicating whether the offset should be added.
   instr = (instr & ~B23) | (positive ? B23 : 0);
   // Set the actual offset.
@@ -735,6 +742,12 @@ bool Assembler::IsBlxIp(Instr instr) {
   return instr == kBlxIp;
 }
 
+#if defined(UC_BUILD_TF_LLVM_BACKEND)
+bool Assembler::IsBlOffset(Instr instr) {
+  return (instr & kBlOffsetMask) == kBlOffsetPattern;
+}
+#endif
+
 bool Assembler::IsTstImmediate(Instr instr) {
   return (instr & (B27 | B26 | I | kOpCodeMask | S | kRdMask)) == (I | TST | S);
 }
diff --git a/src/codegen/arm/assembler-arm.h b/src/codegen/arm/assembler-arm.h
index f669943f34..1d5702cb90 100644
--- a/src/codegen/arm/assembler-arm.h
+++ b/src/codegen/arm/assembler-arm.h
@@ -1085,6 +1085,9 @@ class V8_EXPORT_PRIVATE Assembler : public AssemblerBase {
   static bool IsVldrDPcImmediateOffset(Instr instr);
   static bool IsBlxReg(Instr instr);
   static bool IsBlxIp(Instr instr);
+#if defined(UC_BUILD_TF_LLVM_BACKEND)
+  static bool IsBlOffset(Instr instr);
+#endif
   static bool IsTstImmediate(Instr instr);
   static bool IsCmpRegister(Instr instr);
   static bool IsCmpImmediate(Instr instr);
@@ -1273,8 +1276,19 @@ class V8_EXPORT_PRIVATE Assembler : public AssemblerBase {
   void bind_to(Label* L, int pos);
   void next(Label* L);
 
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+ public:
   // Record reloc info for current pc_
   void RecordRelocInfo(RelocInfo::Mode rmode, intptr_t data = 0);
+  void reset_pc(int pc_offset) { pc_ = buffer_start() + pc_offset; }
+  void LLVMGrowBuffer() { GrowBuffer(); }
+  int LLVMAddCodeTarget(Handle<Code> target) { return AddCodeTarget(target); }
+
+ private:
+#else
+  // Record reloc info for current pc_
+  void RecordRelocInfo(RelocInfo::Mode rmode, intptr_t data = 0);
+#endif
   void ConstantPoolAddEntry(int position, RelocInfo::Mode rmode,
                             intptr_t value);
   void AllocateAndInstallRequestedHeapObjects(Isolate* isolate);
diff --git a/src/codegen/arm/constants-arm.h b/src/codegen/arm/constants-arm.h
index 66eea2180b..8d109cf458 100644
--- a/src/codegen/arm/constants-arm.h
+++ b/src/codegen/arm/constants-arm.h
@@ -656,8 +656,10 @@ class Instruction {
       if (pre == kDoublePrecision) {
         return reg_num;
       }
+#if !defined(UC_BUILD_TF_LLVM_BACKEND)
       DCHECK_EQ(kSimd128Precision, pre);
       DCHECK_EQ(reg_num & 1, 0);
+#endif
       return reg_num / 2;
     }
   }
diff --git a/src/codegen/optimized-compilation-info.h b/src/codegen/optimized-compilation-info.h
index 624517283e..1894567193 100644
--- a/src/codegen/optimized-compilation-info.h
+++ b/src/codegen/optimized-compilation-info.h
@@ -89,6 +89,10 @@ class V8_EXPORT_PRIVATE OptimizedCompilationInfo final {
   Code::Kind code_kind() const { return code_kind_; }
   int32_t builtin_index() const { return builtin_index_; }
   void set_builtin_index(int32_t index) { builtin_index_ = index; }
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+  bool is_llvm_enabled() const { return llvm_enabled_; }
+  void set_llvm_enabled(bool _llvm_enabled) { llvm_enabled_ = _llvm_enabled; }
+#endif
   BailoutId osr_offset() const { return osr_offset_; }
   JavaScriptFrame* osr_frame() const { return osr_frame_; }
 
@@ -308,6 +312,9 @@ class V8_EXPORT_PRIVATE OptimizedCompilationInfo final {
 
   Code::Kind code_kind_;
   int32_t builtin_index_ = -1;
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+  bool llvm_enabled_ = false;
+#endif
 
   // We retain a reference the bytecode array specifically to ensure it doesn't
   // get flushed while we are optimizing the code.
diff --git a/src/common/globals.h b/src/common/globals.h
index a0584b95c4..2250b20920 100644
--- a/src/common/globals.h
+++ b/src/common/globals.h
@@ -538,7 +538,12 @@ constexpr uint64_t kSlotsZapValue = uint64_t{0xbeefdeadbeefdeef};
 constexpr uint64_t kFreeListZapValue = 0xfeed1eaffeed1eaf;
 #else
 constexpr uint32_t kClearedFreeMemoryValue = 0;
+#if defined(UC_BUILD_BUG_FIX)
+// use 3 at lowest bits for weak object reference.
+constexpr uint32_t kZapValue = 0xf0f0f1f1;
+#else
 constexpr uint32_t kZapValue = 0xdeadbeef;
+#endif
 constexpr uint32_t kHandleZapValue = 0xbaddeaf;
 constexpr uint32_t kGlobalHandleZapValue = 0xbaffedf;
 constexpr uint32_t kFromSpaceZapValue = 0xbeefdaf;
diff --git a/src/compiler/backend/code-generator.cc b/src/compiler/backend/code-generator.cc
index e7702bcdf6..31b312bb6c 100644
--- a/src/compiler/backend/code-generator.cc
+++ b/src/compiler/backend/code-generator.cc
@@ -19,6 +19,9 @@
 #include "src/logging/log.h"
 #include "src/objects/smi.h"
 #include "src/utils/address-map.h"
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+#include "src/llvm/tf/v8-code-assemble.h"
+#endif
 
 namespace v8 {
 namespace internal {
@@ -141,6 +144,12 @@ void CodeGenerator::MaybeEmitOutOfLineConstantPool() {
 
 void CodeGenerator::AssembleCode() {
   OptimizedCompilationInfo* info = this->info();
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+  if (compiler_state_) {
+    AssembleCodeLLVM();
+    return;
+  }
+#endif
 
   // Open a frame scope to indicate that there is a frame on the stack.  The
   // MANUAL indicates that the scope shouldn't actually generate code to set up
@@ -1270,6 +1279,14 @@ void CodeGenerator::ResetSpeculationPoison() {
   }
 }
 
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+void CodeGenerator::AssembleCodeLLVM() {
+  CHECK(tf_llvm::AssembleCode(*compiler_state_, tasm(), safepoints(),
+                              &handler_table_offset_));
+  result_ = kSuccess;
+}
+#endif
+
 OutOfLineCode::OutOfLineCode(CodeGenerator* gen)
     : frame_(gen->frame()), tasm_(gen->tasm()), next_(gen->ools_) {
   gen->ools_ = this;
diff --git a/src/compiler/backend/code-generator.h b/src/compiler/backend/code-generator.h
index e9ebf67590..d7cf93a86b 100644
--- a/src/compiler/backend/code-generator.h
+++ b/src/compiler/backend/code-generator.h
@@ -18,6 +18,11 @@
 
 namespace v8 {
 namespace internal {
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+namespace tf_llvm {
+struct CompilerState;
+}
+#endif
 
 class OptimizedCompilationInfo;
 
@@ -168,6 +173,9 @@ class V8_EXPORT_PRIVATE CodeGenerator final : public GapResolver::Assembler {
   }
 
   static constexpr int kBinarySearchSwitchMinimalCases = 4;
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+  void set_compiler_state(tf_llvm::CompilerState* s) { compiler_state_ = s; }
+#endif
 
  private:
   GapResolver* resolver() { return &resolver_; }
@@ -388,6 +396,9 @@ class V8_EXPORT_PRIVATE CodeGenerator final : public GapResolver::Assembler {
   DeoptimizationExit* AddDeoptimizationExit(Instruction* instr,
                                             size_t frame_state_offset);
 
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+  void AssembleCodeLLVM();
+#endif
   // ===========================================================================
 
   struct HandlerInfo {
@@ -451,6 +462,9 @@ class V8_EXPORT_PRIVATE CodeGenerator final : public GapResolver::Assembler {
   ZoneVector<int> block_starts_;
   TurbolizerCodeOffsetsInfo offsets_info_;
   ZoneVector<TurbolizerInstructionStartInfo> instr_starts_;
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+  tf_llvm::CompilerState* compiler_state_;
+#endif
 };
 
 }  // namespace compiler
diff --git a/src/compiler/code-assembler.cc b/src/compiler/code-assembler.cc
index 4f18011463..6895b2ce96 100644
--- a/src/compiler/code-assembler.cc
+++ b/src/compiler/code-assembler.cc
@@ -41,6 +41,58 @@ static_assert(
     !std::is_convertible<TNode<UnionT<Smi, HeapObject>>, TNode<Number>>::value,
     "test subtyping");
 
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+static void ConfigLLVMBuiltins(int32_t builtin_index,
+                        compiler::CodeAssemblerState* state) {
+  switch (builtin_index) {
+    case Builtins::kMathAcos:
+    case Builtins::kMathAcosh:
+    case Builtins::kMathAsin:
+    case Builtins::kMathAsinh:
+    case Builtins::kMathAtan:
+    case Builtins::kMathAtan2:
+    case Builtins::kMathAtanh:
+    case Builtins::kMathCbrt:
+    case Builtins::kMathCos:
+    case Builtins::kMathCosh:
+    case Builtins::kMathExp:
+    case Builtins::kMathExpm1:
+    case Builtins::kMathFround:
+    case Builtins::kMathLog:
+    case Builtins::kMathLog1p:
+    case Builtins::kMathLog10:
+    case Builtins::kMathLog2:
+    case Builtins::kMathSin:
+    case Builtins::kMathSign:
+    case Builtins::kMathSinh:
+    case Builtins::kMathSqrt:
+    case Builtins::kMathTan:
+    case Builtins::kMathTanh:
+    case Builtins::kMathCeil:
+    case Builtins::kMathFloor:
+    case Builtins::kMathPow:
+    case Builtins::kMathMax:
+    case Builtins::kMathMin:
+    case Builtins::kExponentiate:
+    case Builtins::kAtomicsLoad:
+    case Builtins::kAtomicsStore:
+    case Builtins::kAtomicsExchange:
+    case Builtins::kAtomicsCompareExchange:
+    case Builtins::kAtomicsAdd:
+    case Builtins::kAtomicsSub:
+    case Builtins::kAtomicsAnd:
+    case Builtins::kAtomicsOr:
+    case Builtins::kAtomicsXor:
+    case Builtins::kWasmRecordWrite:
+      state->set_llvm_enabled(false);
+      break;
+    default:
+      state->set_llvm_enabled(true);
+      break;
+  }
+}
+#endif
+
 CodeAssemblerState::CodeAssemblerState(
     Isolate* isolate, Zone* zone, const CallInterfaceDescriptor& descriptor,
     Code::Kind kind, const char* name, PoisoningMitigationLevel poisoning_level,
@@ -82,7 +134,11 @@ CodeAssemblerState::CodeAssemblerState(Isolate* isolate, Zone* zone,
       name_(name),
       builtin_index_(builtin_index),
       code_generated_(false),
-      variables_(zone) {}
+      variables_(zone) {
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+  ConfigLLVMBuiltins(builtin_index, this);
+#endif
+}
 
 CodeAssemblerState::~CodeAssemblerState() = default;
 
@@ -177,11 +233,20 @@ Handle<Code> CodeAssembler::GenerateCode(CodeAssemblerState* state,
   Handle<Code> code;
   Graph* graph = rasm->ExportForOptimization();
 
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+  code = Pipeline::GenerateCodeForCodeStub(
+             rasm->isolate(), rasm->call_descriptor(), graph,
+             rasm->source_positions(), state->kind_, state->name_,
+             state->builtin_index_, rasm->poisoning_level(), options,
+             state->is_llvm_enabled())
+             .ToHandleChecked();
+#else
   code = Pipeline::GenerateCodeForCodeStub(
              rasm->isolate(), rasm->call_descriptor(), graph,
              rasm->source_positions(), state->kind_, state->name_,
              state->builtin_index_, rasm->poisoning_level(), options)
              .ToHandleChecked();
+#endif
 
   state->code_generated_ = true;
   return code;
diff --git a/src/compiler/code-assembler.h b/src/compiler/code-assembler.h
index c9adb1601d..25328c0ad0 100644
--- a/src/compiler/code-assembler.h
+++ b/src/compiler/code-assembler.h
@@ -1746,6 +1746,10 @@ class V8_EXPORT_PRIVATE CodeAssemblerState {
 
   const char* name() const { return name_; }
   int parameter_count() const;
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+  void set_llvm_enabled(bool enable) { llvm_enabled_ = enable; }
+  bool is_llvm_enabled() const { return llvm_enabled_; }
+#endif
 
 #if DEBUG
   void PrintCurrentBlock(std::ostream& os);
@@ -1781,6 +1785,9 @@ class V8_EXPORT_PRIVATE CodeAssemblerState {
   std::vector<CodeAssemblerExceptionHandlerLabel*> exception_handler_labels_;
   using VariableId = uint32_t;
   VariableId next_variable_id_ = 0;
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+  bool llvm_enabled_ = false;
+#endif
 
   VariableId NextVariableId() { return next_variable_id_++; }
 
diff --git a/src/compiler/pipeline.cc b/src/compiler/pipeline.cc
index 8b2f424789..0f9a855eca 100644
--- a/src/compiler/pipeline.cc
+++ b/src/compiler/pipeline.cc
@@ -92,6 +92,10 @@
 #include "src/wasm/function-body-decoder.h"
 #include "src/wasm/function-compiler.h"
 #include "src/wasm/wasm-engine.h"
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+#include "src/llvm/compiler-state.h"
+#include "src/llvm/tf/v8-pass-manager.h"
+#endif
 
 namespace v8 {
 namespace internal {
@@ -446,6 +450,9 @@ class PipelineData {
         info()->GetPoisoningMitigationLevel(), assembler_options_,
         info_->builtin_index(), max_unoptimized_frame_height(),
         std::move(buffer));
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+    code_generator_->set_compiler_state(compiler_state_.get());
+#endif
   }
 
   void BeginPhaseKind(const char* phase_kind_name) {
@@ -465,6 +472,12 @@ class PipelineData {
   bool roots_relative_addressing_enabled() {
     return roots_relative_addressing_enabled_;
   }
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+  tf_llvm::CompilerState* compiler_state() { return compiler_state_.get(); }
+  void set_compiler_state(std::unique_ptr<tf_llvm::CompilerState>&& s) {
+    compiler_state_ = std::move(s);
+  }
+#endif
 
  private:
   Isolate* const isolate_;
@@ -536,6 +549,9 @@ class PipelineData {
   // state. Calculated during instruction selection, applied during code
   // generation.
   size_t max_unoptimized_frame_height_ = 0;
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+  std::unique_ptr<tf_llvm::CompilerState> compiler_state_;
+#endif
 
   DISALLOW_COPY_AND_ASSIGN(PipelineData);
 };
@@ -2359,13 +2375,25 @@ bool PipelineImpl::OptimizeGraph(Linkage* linkage) {
   return SelectInstructions(linkage);
 }
 
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+MaybeHandle<Code> Pipeline::GenerateCodeForCodeStub(
+    Isolate* isolate, CallDescriptor* call_descriptor, Graph* graph,
+    SourcePositionTable* source_positions, Code::Kind kind,
+    const char* debug_name, int32_t builtin_index,
+    PoisoningMitigationLevel poisoning_level, const AssemblerOptions& options,
+    bool llvm_enabled) {
+#else
 MaybeHandle<Code> Pipeline::GenerateCodeForCodeStub(
     Isolate* isolate, CallDescriptor* call_descriptor, Graph* graph,
     SourcePositionTable* source_positions, Code::Kind kind,
     const char* debug_name, int32_t builtin_index,
     PoisoningMitigationLevel poisoning_level, const AssemblerOptions& options) {
+#endif
   OptimizedCompilationInfo info(CStrVector(debug_name), graph->zone(), kind);
   info.set_builtin_index(builtin_index);
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+  info.set_llvm_enabled(llvm_enabled);
+#endif
 
   if (poisoning_level != PoisoningMitigationLevel::kDontPoison) {
     info.SetPoisoningMitigationLevel(poisoning_level);
@@ -2793,6 +2821,30 @@ bool PipelineImpl::SelectInstructions(Linkage* linkage) {
         info(), data->graph(), data->schedule(), data->isolate()));
   }
 
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+  if (info()->is_llvm_enabled()) {
+    tf_llvm::V8PassManager pass_manager;
+    auto debug_name = info()->GetDebugName();
+    auto compiler_state = pass_manager.SelectInstructions(
+        data->isolate(), data->schedule(), data->source_positions(),
+        call_descriptor, debug_name.get(), info()->code_kind(),
+        info()->builtin_index());
+    // Allocate frame slots.
+    int frame_slots_count = compiler_state->sm_.stackSize() / kPointerSize;
+    // fake instruction sequence.
+    data->InitializeInstructionSequence(call_descriptor);
+    data->InitializeFrameData(nullptr);
+    Frame* frame = data->frame();
+    while (frame->GetTotalFrameSlotCount() < frame_slots_count)
+      frame->AllocateSpillSlot(kPointerSize);
+    CHECK(frame->GetTotalFrameSlotCount() == frame_slots_count);
+    data->set_compiler_state(std::move(compiler_state));
+    data->DeleteGraphZone();
+    data->EndPhaseKind();
+    return true;
+  }
+#endif
+
   bool verify_stub_graph = data->verify_graph();
   // Jump optimization runs instruction selection twice, but the instruction
   // selector mutates nodes like swapping the inputs of a load, which can
diff --git a/src/compiler/pipeline.h b/src/compiler/pipeline.h
index 3707bfb06e..e35fcb7c97 100644
--- a/src/compiler/pipeline.h
+++ b/src/compiler/pipeline.h
@@ -67,6 +67,15 @@ class Pipeline : public AllStatic {
       const AssemblerOptions& options,
       SourcePositionTable* source_positions = nullptr);
 
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+  // Run the pipeline on a machine graph and generate code.
+  static MaybeHandle<Code> GenerateCodeForCodeStub(
+      Isolate* isolate, CallDescriptor* call_descriptor, Graph* graph,
+      SourcePositionTable* source_positions, Code::Kind kind,
+      const char* debug_name, int32_t builtin_index,
+      PoisoningMitigationLevel poisoning_level, const AssemblerOptions& options,
+      bool llvm_enabled);
+#else
   // Run the pipeline on a machine graph and generate code.
   static MaybeHandle<Code> GenerateCodeForCodeStub(
       Isolate* isolate, CallDescriptor* call_descriptor, Graph* graph,
@@ -74,6 +83,7 @@ class Pipeline : public AllStatic {
       const char* debug_name, int32_t builtin_index,
       PoisoningMitigationLevel poisoning_level,
       const AssemblerOptions& options);
+#endif
 
   // ---------------------------------------------------------------------------
   // The following methods are for testing purposes only. Avoid production use.
diff --git a/src/compiler/schedule.cc b/src/compiler/schedule.cc
index 3b335f9712..e5b0fcf929 100644
--- a/src/compiler/schedule.cc
+++ b/src/compiler/schedule.cc
@@ -450,7 +450,12 @@ std::ostream& operator<<(std::ostream& os, const Schedule& s) {
     if (block->rpo_number() == -1) {
       os << "--- BLOCK id:" << block->id().ToInt();
     } else {
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+      os << "--- BLOCK B" << block->rpo_number()
+         << " id: " << block->id().ToInt();
+#else
       os << "--- BLOCK B" << block->rpo_number();
+#endif
     }
     if (block->deferred()) os << " (deferred)";
     if (block->PredecessorCount() != 0) os << " <- ";
diff --git a/src/compiler/scheduler.cc b/src/compiler/scheduler.cc
index bf23e436f6..3781eb0b70 100644
--- a/src/compiler/scheduler.cc
+++ b/src/compiler/scheduler.cc
@@ -1724,6 +1724,9 @@ void Scheduler::ScheduleLate() {
 void Scheduler::SealFinalSchedule() {
   TRACE("--- SEAL FINAL SCHEDULE ------------------------------------\n");
 
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+  SplitAroundCalls();
+#endif
   // Serialize the assembly order and reverse-post-order numbering.
   special_rpo_->SerializeRPOIntoSchedule();
   special_rpo_->PrintAndVerifySpecialRPO();
@@ -1741,6 +1744,71 @@ void Scheduler::SealFinalSchedule() {
   }
 }
 
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+void Scheduler::SplitAroundCalls() {
+  ZoneDeque<NodeVector*> work_list(zone_);
+  std::copy(scheduled_nodes_.begin(), scheduled_nodes_.end(),
+            std::back_inserter(work_list));
+  while (!work_list.empty()) {
+    NodeVector* nodes = work_list.front();
+    work_list.pop_front();
+    if (!nodes || nodes->empty()) continue;
+    auto found = std::find_if(nodes->rbegin(), nodes->rend(), [](Node* n) {
+      return n->opcode() == IrOpcode::kCall;
+    });
+    if (nodes->rend() == found) continue;
+    // ignore those call is at the end.
+    if (nodes->rend() == found) continue;
+    Node* call = *found;
+    // Build new block.
+    BasicBlock* part1 = schedule_->block(call);
+    BasicBlock* part2 = schedule_->NewBasicBlock();
+    part2->successors() = std::move(part1->successors());
+    part2->set_control(part1->control());
+    part2->set_control_input(part1->control_input());
+    part1->set_control_input(nullptr);
+    part1->set_control(BasicBlock::kNone);
+    part2->set_rpo_next(part1->rpo_next());
+    part1->set_rpo_next(part2);
+    part2->set_deferred(part1->deferred());
+    part2->set_loop_depth(part1->loop_depth());
+    schedule_->AddGoto(part1, part2);
+    // Reset the successors/predecessors relationship.
+    for (BasicBlock* part2_successor : part2->successors()) {
+      for (BasicBlock*& pred : part2_successor->predecessors()) {
+        if (pred == part1) pred = part2;
+      }
+    }
+
+    // Reset the dominate relationship.
+    for (BasicBlock* b : *schedule_->all_blocks()) {
+      if (b->dominator() == part1) b->set_dominator(part2);
+    }
+    part2->set_dominator(part1);
+
+    // Migrate nodes.
+    auto after_call = found + 1;
+    NodeVector* new_vector =
+        new (zone_->New(sizeof(NodeVector))) NodeVector(zone_);
+    CHECK_EQ(scheduled_nodes_.size(), part2->id().ToSize());
+    scheduled_nodes_.emplace_back(new_vector);
+    size_t distance = std::distance(after_call, nodes->rend());
+    for (size_t i = 0; i < distance; ++i) {
+      new_vector->push_back(nodes->at(i));
+    }
+
+    nodes->erase(nodes->begin(), nodes->begin() + distance);
+
+    // push new vector to work list for further
+    work_list.emplace_back(new_vector);
+
+    // Replan all the node for new vector
+    for (Node* node : *new_vector) schedule_->SetBlockForNode(part2, node);
+    if (part2->control_input())
+      schedule_->SetBlockForNode(part2, part2->control_input());
+  }
+}
+#endif
 
 // -----------------------------------------------------------------------------
 
diff --git a/src/compiler/scheduler.h b/src/compiler/scheduler.h
index 3d1fa40025..1fa65eb54b 100644
--- a/src/compiler/scheduler.h
+++ b/src/compiler/scheduler.h
@@ -123,6 +123,10 @@ class V8_EXPORT_PRIVATE Scheduler {
 
   // Phase 6: Seal the final schedule.
   void SealFinalSchedule();
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+  // Phase 6.1: Split around calls
+  void SplitAroundCalls();
+#endif
 
   void FuseFloatingControl(BasicBlock* block, Node* node);
   void MovePlannedNodes(BasicBlock* from, BasicBlock* to);
diff --git a/src/compiler/wasm-compiler.cc b/src/compiler/wasm-compiler.cc
index 28f9943e59..092efb68b3 100644
--- a/src/compiler/wasm-compiler.cc
+++ b/src/compiler/wasm-compiler.cc
@@ -6877,6 +6877,9 @@ wasm::WasmCompilationResult ExecuteTurbofanWasmCompilation(
 
   OptimizedCompilationInfo info(GetDebugName(&zone, func_index), &zone,
                                 Code::WASM_FUNCTION);
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+  if (FLAG_mkwasmllvm) info.set_llvm_enabled(true);
+#endif
   if (env->runtime_exception_support) {
     info.SetWasmRuntimeExceptionSupport();
   }
diff --git a/src/diagnostics/arm/disasm-arm.cc b/src/diagnostics/arm/disasm-arm.cc
index 51b6594e70..7856978c66 100644
--- a/src/diagnostics/arm/disasm-arm.cc
+++ b/src/diagnostics/arm/disasm-arm.cc
@@ -946,7 +946,11 @@ void Decoder::DecodeType01(Instruction* instr) {
         } else {
           // Other instructions matching this pattern are handled in the
           // miscellaneous instructions part above.
+#if !defined(UC_BUILD_TF_LLVM_BACKEND)
           UNREACHABLE();
+#else
+          Format(instr, "unknown");
+#endif
         }
         break;
       }
@@ -964,7 +968,11 @@ void Decoder::DecodeType01(Instruction* instr) {
         } else {
           // Other instructions matching this pattern are handled in the
           // miscellaneous instructions part above.
+#if !defined(UC_BUILD_TF_LLVM_BACKEND)
           UNREACHABLE();
+#else
+          Format(instr, "unknown");
+#endif
         }
         break;
       }
@@ -1063,10 +1071,18 @@ void Decoder::DecodeType3(Instruction* instr) {
               }
               break;
             case 1:
+#if !defined(UC_BUILD_TF_LLVM_BACKEND)
               UNREACHABLE();
+#else
+              Format(instr, "unknown");
+#endif
               break;
             case 2:
+#if !defined(UC_BUILD_TF_LLVM_BACKEND)
               UNREACHABLE();
+#else
+              Format(instr, "unknown");
+#endif
               break;
             case 3:
               Format(instr, "usat 'rd, #'imm05@16, 'rm'shift_sat");
@@ -1169,10 +1185,18 @@ void Decoder::DecodeType3(Instruction* instr) {
                       break;
                   }
                 } else {
+#if !defined(UC_BUILD_TF_LLVM_BACKEND)
                   UNREACHABLE();
+#else
+                  Format(instr, "unknown");
+#endif
                 }
               } else {
+#if !defined(UC_BUILD_TF_LLVM_BACKEND)
                 UNREACHABLE();
+#else
+                Format(instr, "unknown");
+#endif
               }
               break;
             case 3:
@@ -1248,7 +1272,11 @@ void Decoder::DecodeType3(Instruction* instr) {
                     (instr->Bits(11, 4) == 0xF3)) {
                   Format(instr, "rbit'cond 'rd, 'rm");
                 } else {
+#if !defined(UC_BUILD_TF_LLVM_BACKEND)
                   UNREACHABLE();
+#else
+                  Format(instr, "unknown");
+#endif
                 }
               }
               break;
@@ -2519,12 +2547,16 @@ bool Decoder::IsConstantPoolAt(byte* instr_ptr) {
 }
 
 int Decoder::ConstantPoolSizeAt(byte* instr_ptr) {
+#if !defined(UC_BUILD_TF_LLVM_BACKEND)
   if (IsConstantPoolAt(instr_ptr)) {
     int instruction_bits = *(reinterpret_cast<int*>(instr_ptr));
     return DecodeConstantPoolLength(instruction_bits);
   } else {
     return -1;
   }
+#else
+  return -1;
+#endif
 }
 
 // Disassemble the instruction at *instr_ptr into the output buffer.
diff --git a/src/flags/flag-definitions.h b/src/flags/flag-definitions.h
index c7c07e6dc6..25b9f0a8fe 100644
--- a/src/flags/flag-definitions.h
+++ b/src/flags/flag-definitions.h
@@ -1249,6 +1249,9 @@ DEFINE_BOOL(serialization_statistics, false,
             "Collect statistics on serialized objects.")
 DEFINE_UINT(serialization_chunk_size, 4096,
             "Custom size for serialization chunks")
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+DEFINE_BOOL(mkwasmllvm, false, "building for wasm")
+#endif
 
 // Regexp
 DEFINE_BOOL(regexp_optimization, true, "generate optimized regexp code")
diff --git a/src/interpreter/interpreter-generator.cc b/src/interpreter/interpreter-generator.cc
index e8569ecd55..e85cde3938 100644
--- a/src/interpreter/interpreter-generator.cc
+++ b/src/interpreter/interpreter-generator.cc
@@ -58,6 +58,30 @@ using Variable = CodeStubAssembler::Variable;
   }                                                                   \
   void Name##Assembler::GenerateImpl()
 
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+#define IGNITION_HANDLER_LLVM(Name, BaseAssembler)                    \
+  class Name##Assembler : public BaseAssembler {                      \
+   public:                                                            \
+    explicit Name##Assembler(compiler::CodeAssemblerState* state,     \
+                             Bytecode bytecode, OperandScale scale)   \
+        : BaseAssembler(state, bytecode, scale) {}                    \
+    static void Generate(compiler::CodeAssemblerState* state,         \
+                         OperandScale scale);                         \
+                                                                      \
+   private:                                                           \
+    void GenerateImpl();                                              \
+    DISALLOW_COPY_AND_ASSIGN(Name##Assembler);                        \
+  };                                                                  \
+  void Name##Assembler::Generate(compiler::CodeAssemblerState* state, \
+                                 OperandScale scale) {                \
+    Name##Assembler assembler(state, Bytecode::k##Name, scale);       \
+    state->set_llvm_enabled(true);                                    \
+    state->SetInitialDebugInformation(#Name, __FILE__, __LINE__);     \
+    assembler.GenerateImpl();                                         \
+  }                                                                   \
+  void Name##Assembler::GenerateImpl()
+#endif
+
 // LdaZero
 //
 // Load literal '0' into the accumulator.
diff --git a/src/objects/code.cc b/src/objects/code.cc
index b416df8878..dfed39c1f3 100644
--- a/src/objects/code.cc
+++ b/src/objects/code.cc
@@ -781,6 +781,9 @@ void Code::Disassemble(const char* name, std::ostream& os, Address current_pc) {
     if (kind() == OPTIMIZED_FUNCTION) {
       table.HandlerTableReturnPrint(os);
     }
+#if defined(UC_BUILD_TF_LLVM_BACKEND) && USE_SIMULATOR
+    table.HandlerTableReturnPrint(os);
+#endif
     os << "\n";
   }
 
diff --git a/src/profiler/cpu-profiler.cc b/src/profiler/cpu-profiler.cc
index 4c35159b2e..f322a22fcc 100644
--- a/src/profiler/cpu-profiler.cc
+++ b/src/profiler/cpu-profiler.cc
@@ -17,6 +17,9 @@
 #include "src/profiler/cpu-profiler-inl.h"
 #include "src/utils/locked-queue-inl.h"
 #include "src/wasm/wasm-engine.h"
+#if defined(FEATURE_PROFILER_COLLECT_RAW_INFO)
+#include <fstream>
+#endif
 
 namespace v8 {
 namespace internal {
@@ -529,6 +532,13 @@ void CpuProfiler::StartProcessorIfNotStarted() {
     DCHECK_EQ(logging_mode_, kLazyLogging);
     EnableLogging();
   }
+#if defined(FEATURE_PROFILER_COLLECT_RAW_INFO)
+  char name[256];
+  snprintf(name, 256, "/sdcard/v8_profile_details_%08x.log",
+           static_cast<int>(time(nullptr)));
+  profile_detail_.reset(new std::ofstream(name));
+  if (profile_detail_->fail()) __builtin_trap();
+#endif
 
   if (!generator_) {
     generator_.reset(
diff --git a/src/profiler/cpu-profiler.h b/src/profiler/cpu-profiler.h
index 093f28aba3..e14ea515c9 100644
--- a/src/profiler/cpu-profiler.h
+++ b/src/profiler/cpu-profiler.h
@@ -313,6 +313,9 @@ class V8_EXPORT_PRIVATE CpuProfiler {
   ProfileGenerator* generator() const { return generator_.get(); }
   ProfilerEventsProcessor* processor() const { return processor_.get(); }
   Isolate* isolate() const { return isolate_; }
+#if defined(FEATURE_PROFILER_COLLECT_RAW_INFO)
+  std::ostream& os() { return *profile_detail_; }
+#endif
 
   ProfilerListener* profiler_listener_for_test() {
     return profiler_listener_.get();
@@ -345,6 +348,9 @@ class V8_EXPORT_PRIVATE CpuProfiler {
   std::unique_ptr<ProfilerEventsProcessor> processor_;
   std::unique_ptr<ProfilerListener> profiler_listener_;
   std::unique_ptr<ProfilingScope> profiling_scope_;
+#if defined(FEATURE_PROFILER_COLLECT_RAW_INFO)
+  std::unique_ptr<std::ostream> profile_detail_;
+#endif
   ProfilerCodeObserver code_observer_;
   bool is_profiling_;
 
diff --git a/src/profiler/profile-generator.cc b/src/profiler/profile-generator.cc
index f5f7184613..fcfd1577bd 100644
--- a/src/profiler/profile-generator.cc
+++ b/src/profiler/profile-generator.cc
@@ -11,6 +11,10 @@
 #include "src/profiler/profile-generator-inl.h"
 #include "src/tracing/trace-event.h"
 #include "src/tracing/traced-value.h"
+#if defined(FEATURE_PROFILER_COLLECT_RAW_INFO)
+#include "src/code-stubs.h"
+#include "src/interpreter/interpreter.h"
+#endif
 
 namespace v8 {
 namespace internal {
@@ -858,6 +862,12 @@ void CpuProfilesCollection::AddPathToCurrentProfiles(
   current_profiles_semaphore_.Signal();
 }
 
+#if defined(FEATURE_PROFILER_COLLECT_RAW_INFO)
+Isolate* CpuProfilesCollection::isolate() { return profiler_->isolate(); }
+
+std::ostream& CpuProfilesCollection::os() { return profiler_->os(); }
+#endif
+
 void CpuProfilesCollection::UpdateNativeContextAddressForCurrentProfiles(
     Address from, Address to) {
   current_profiles_semaphore_.Wait();
@@ -994,6 +1004,48 @@ void ProfileGenerator::RecordTickSample(const TickSample& sample) {
       }
       stack_trace.push_back({{entry, line_number}, native_context, true});
     }
+#if defined(FEATURE_PROFILER_COLLECT_RAW_INFO)
+    bool handled = false;
+    do {
+      const char* name = nullptr;
+      Isolate* isolate = profiles_->isolate();
+      if (!isolate->heap()->code_space()->ContainsSlow(
+              reinterpret_cast<i::Address>(sample.pc)))
+        break;
+      handled = true;
+      i::Code* code =
+          isolate->FindCodeObject(reinterpret_cast<i::Address>(sample.pc));
+      if (code) {
+        std::ostream& os = profiles_->os();
+        os << "kind = " << i::Code::Kind2String(code->kind()) << ";";
+        os << "offset = "
+           << static_cast<byte* const>(sample.pc) -
+                  code->raw_instruction_start()
+           << ";";
+
+        if (code->is_stub()) {
+          const char* n =
+              i::CodeStub::MajorName(i::CodeStub::GetMajorKey(code));
+          os << "major_key = " << (n == NULL ? "null" : n) << ";";
+        }
+        if (code->kind() == i::Code::BYTECODE_HANDLER) {
+          name = isolate->interpreter()->LookupNameOfBytecodeHandler(code);
+          if (name != nullptr) {
+            os << "name = " << name << ";";
+          }
+        } else {
+          // There are some handlers and ICs that we can also find names for
+          // with
+          // Builtins::Lookup.
+          name = isolate->builtins()->Lookup(code->raw_instruction_start());
+          if (name != nullptr) {
+            os << "name = " << name << ";";
+          }
+        }
+        os << "\n";
+      }
+    } while (false);
+#endif
   }
 
   if (FLAG_prof_browser_mode) {
diff --git a/src/snapshot/embedded/platform-embedded-file-writer-generic.cc b/src/snapshot/embedded/platform-embedded-file-writer-generic.cc
index f4183b4b87..a25b860417 100644
--- a/src/snapshot/embedded/platform-embedded-file-writer-generic.cc
+++ b/src/snapshot/embedded/platform-embedded-file-writer-generic.cc
@@ -108,6 +108,14 @@ void PlatformEmbeddedFileWriterGeneric::DeclareFunctionBegin(const char* name) {
     // to create a DWARF subprogram entry.
     fprintf(fp_, ".type %s, @function\n", name);
   }
+#if defined(UC_BUILD_BUG_FIX)
+  // Impose arm instruction set.
+  if (target_arch_ == EmbeddedTargetArch::kArm) {
+    fprintf(fp_, ".arm\n");
+    fprintf(fp_, ".hidden %s\n", name);
+    fprintf(fp_, ".globl %s\n", name);
+  }
+#endif
 }
 
 void PlatformEmbeddedFileWriterGeneric::DeclareFunctionEnd(const char* name) {}
diff --git a/src/snapshot/serializer-common.h b/src/snapshot/serializer-common.h
index 2a30fefe33..2bc0c5d399 100644
--- a/src/snapshot/serializer-common.h
+++ b/src/snapshot/serializer-common.h
@@ -332,8 +332,16 @@ class SerializedData {
   using IsLastChunkBits = BitField<bool, 31, 1>;
 
   static constexpr uint32_t kMagicNumberOffset = 0;
+#if defined(UC_BUILD_TF_LLVM_BACKEND)
+  static constexpr uint32_t kMagicNumber =
+      0xD0DEBA00 ^ ExternalReferenceTable::kSize;
+#elif defined(UC_BUILD)
+  static constexpr uint32_t kMagicNumber =
+      0xD0DEBD00 ^ ExternalReferenceTable::kSize;
+#else
   static constexpr uint32_t kMagicNumber =
       0xC0DE0000 ^ ExternalReferenceTable::kSize;
+#endif
 
  protected:
   void SetHeaderValue(uint32_t offset, uint32_t value) {
diff --git a/src/wasm/wasm-js.cc b/src/wasm/wasm-js.cc
index f10f5ff2bf..7a92185a8d 100644
--- a/src/wasm/wasm-js.cc
+++ b/src/wasm/wasm-js.cc
@@ -1980,6 +1980,57 @@ void SetDummyInstanceTemplate(Isolate* isolate, Handle<JSFunction> fun) {
       instance_template);
 }
 
+#if defined(UC_BUILD_TF_LLVM_BACKEND)
+void DeserializeFromSnapshotForTest(
+    const v8::FunctionCallbackInfo<v8::Value>& args) {
+  v8::Isolate* isolate = args.GetIsolate();
+  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);
+  HandleScope scope(i_isolate);
+  ScheduledErrorThrower thrower(i_isolate,
+                                "WebAssembly.DeserializeFromSnapshot()");
+  if (!args[0]->IsArrayBuffer()) {
+    thrower.TypeError("Argument 0 must be an array buffer object");
+    return;
+  }
+  if (!args[1]->IsArrayBuffer()) {
+    thrower.TypeError("Argument 1 must be an array buffer object");
+    return;
+  }
+  i::Handle<i::JSArrayBuffer> buffer =
+      i::Handle<i::JSArrayBuffer>::cast(v8::Utils::OpenHandle(*args[0]));
+
+  i::Handle<i::JSArrayBuffer> wire_bytes =
+      i::Handle<i::JSArrayBuffer>::cast(v8::Utils::OpenHandle(*args[1]));
+
+  uint8_t* mem_start = reinterpret_cast<uint8_t*>(buffer->backing_store());
+  size_t mem_size = static_cast<size_t>(buffer->byte_length());
+
+  // Note that {wasm::DeserializeNativeModule} will allocate. We assume the
+  // JSArrayBuffer doesn't get relocated.
+  bool already_external = wire_bytes->is_external();
+  if (!already_external) {
+    wire_bytes->set_is_external(true);
+    i_isolate->heap()->UnregisterArrayBuffer(*wire_bytes);
+  }
+  i::MaybeHandle<i::WasmModuleObject> maybe_module_object =
+      i::wasm::DeserializeNativeModule(
+          i_isolate, {mem_start, mem_size},
+          i::Vector<const uint8_t>(
+              reinterpret_cast<uint8_t*>(wire_bytes->backing_store()),
+              static_cast<int>(wire_bytes->byte_length())));
+  if (!already_external) {
+    wire_bytes->set_is_external(false);
+    i_isolate->heap()->RegisterNewArrayBuffer(*wire_bytes);
+  }
+  i::Handle<i::WasmModuleObject> module_object;
+  i::Handle<i::Object> i_result;
+  if (!maybe_module_object.ToHandle(&i_result)) {
+    i_result = i::ReadOnlyRoots(i_isolate).undefined_value_handle();
+  }
+  Local<Value> result = Local<Value>::Cast(Utils::ToLocal(i_result));
+  args.GetReturnValue().Set(result);
+}
+#endif
 // static
 void WasmJs::Install(Isolate* isolate, bool exposed_on_global_object) {
   Handle<JSGlobalObject> global = isolate->global_object();
@@ -2009,6 +2060,10 @@ void WasmJs::Install(Isolate* isolate, bool exposed_on_global_object) {
   InstallFunc(isolate, webassembly, "compile", WebAssemblyCompile, 1);
   InstallFunc(isolate, webassembly, "validate", WebAssemblyValidate, 1);
   InstallFunc(isolate, webassembly, "instantiate", WebAssemblyInstantiate, 1);
+#if 0 && defined(UC_BUILD_TF_LLVM_BACKEND)
+  InstallFunc(isolate, webassembly, "deserializeFromSnapshot",
+              DeserializeFromSnapshotForTest, 2);
+#endif
 
   if (FLAG_wasm_test_streaming) {
     isolate->set_wasm_streaming_callback(WasmStreamingCallbackForTesting);
diff --git a/src/wasm/wasm-serialization.cc b/src/wasm/wasm-serialization.cc
index 81460b9fe2..3d33a0eef6 100644
--- a/src/wasm/wasm-serialization.cc
+++ b/src/wasm/wasm-serialization.cc
@@ -122,10 +122,17 @@ class Reader {
 constexpr size_t kVersionSize = 4 * sizeof(uint32_t);
 
 void WriteVersion(Writer* writer) {
+#if defined(UC_BUILD_TF_LLVM_BACKEND)
+  writer->Write(SerializedData::kMagicNumber);
+  writer->Write(Version::Hash());
+  writer->Write(static_cast<uint32_t>(0xdeadbeef));
+  writer->Write(static_cast<uint32_t>(0xf3e5d98b));
+#else
   writer->Write(SerializedData::kMagicNumber);
   writer->Write(Version::Hash());
   writer->Write(static_cast<uint32_t>(CpuFeatures::SupportedFeatures()));
   writer->Write(FlagList::Hash());
+#endif
 }
 
 // On Intel, call sites are encoded as a displacement. For linking and for
